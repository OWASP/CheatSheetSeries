
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Cross-Site Request Forgery Prevention  Â· OWASP Cheat Sheet Series</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Cross_Site_Scripting_Prevention_Cheat_Sheet.html" />
    
    
    <link rel="prev" href="Credential_Stuffing_Prevention_Cheat_Sheet.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Cheatsheets</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="Index.html">
            
                <a href="Index.html">
            
                    
                    Index Alphabetical
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="IndexASVS.html">
            
                <a href="IndexASVS.html">
            
                    
                    Index ASVS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="IndexProactiveControls.html">
            
                <a href="IndexProactiveControls.html">
            
                    
                    Index Proactive Controls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="AJAX_Security_Cheat_Sheet.html">
            
                <a href="AJAX_Security_Cheat_Sheet.html">
            
                    
                    AJAX Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="Abuse_Case_Cheat_Sheet.html">
            
                <a href="Abuse_Case_Cheat_Sheet.html">
            
                    
                    Abuse Case 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="Access_Control_Cheat_Sheet.html">
            
                <a href="Access_Control_Cheat_Sheet.html">
            
                    
                    Access Control 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="Attack_Surface_Analysis_Cheat_Sheet.html">
            
                <a href="Attack_Surface_Analysis_Cheat_Sheet.html">
            
                    
                    Attack Surface Analysis 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="Authentication_Cheat_Sheet.html">
            
                <a href="Authentication_Cheat_Sheet.html">
            
                    
                    Authentication 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="Authorization_Testing_Automation.html">
            
                <a href="Authorization_Testing_Automation.html">
            
                    
                    Authorization Testing Automation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="Bean_Validation_Cheat_Sheet.html">
            
                <a href="Bean_Validation_Cheat_Sheet.html">
            
                    
                    Bean Validation 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="C-Based_Toolchain_Hardening.html">
            
                <a href="C-Based_Toolchain_Hardening.html">
            
                    
                    C-Based Toolchain Hardening
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="C-Based_Toolchain_Hardening_Cheat_Sheet.html">
            
                <a href="C-Based_Toolchain_Hardening_Cheat_Sheet.html">
            
                    
                    C-Based Toolchain Hardening 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="Choosing_and_Using_Security_Questions_Cheat_Sheet.html">
            
                <a href="Choosing_and_Using_Security_Questions_Cheat_Sheet.html">
            
                    
                    Choosing and Using Security Questions 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="Clickjacking_Defense_Cheat_Sheet.html">
            
                <a href="Clickjacking_Defense_Cheat_Sheet.html">
            
                    
                    Clickjacking Defense 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="Content_Security_Policy_Cheat_Sheet.html">
            
                <a href="Content_Security_Policy_Cheat_Sheet.html">
            
                    
                    Content Security Policy 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="Credential_Stuffing_Prevention_Cheat_Sheet.html">
            
                <a href="Credential_Stuffing_Prevention_Cheat_Sheet.html">
            
                    
                    Credential Stuffing Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.18" data-path="Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">
            
                <a href="Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">
            
                    
                    Cross-Site Request Forgery Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="Cross_Site_Scripting_Prevention_Cheat_Sheet.html">
            
                <a href="Cross_Site_Scripting_Prevention_Cheat_Sheet.html">
            
                    
                    Cross Site Scripting Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="Cryptographic_Storage_Cheat_Sheet.html">
            
                <a href="Cryptographic_Storage_Cheat_Sheet.html">
            
                    
                    Cryptographic Storage 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="DOM_based_XSS_Prevention_Cheat_Sheet.html">
            
                <a href="DOM_based_XSS_Prevention_Cheat_Sheet.html">
            
                    
                    DOM based XSS Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="Denial_of_Service_Cheat_Sheet.html">
            
                <a href="Denial_of_Service_Cheat_Sheet.html">
            
                    
                    Denial of Service 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="Deserialization_Cheat_Sheet.html">
            
                <a href="Deserialization_Cheat_Sheet.html">
            
                    
                    Deserialization 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="Docker_Security_Cheat_Sheet.html">
            
                <a href="Docker_Security_Cheat_Sheet.html">
            
                    
                    Docker Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.25" data-path="DotNet_Security_Cheat_Sheet.html">
            
                <a href="DotNet_Security_Cheat_Sheet.html">
            
                    
                    DotNet Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.26" data-path="Error_Handling_Cheat_Sheet.html">
            
                <a href="Error_Handling_Cheat_Sheet.html">
            
                    
                    Error Handling 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.27" data-path="Forgot_Password_Cheat_Sheet.html">
            
                <a href="Forgot_Password_Cheat_Sheet.html">
            
                    
                    Forgot Password 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.28" data-path="HTML5_Security_Cheat_Sheet.html">
            
                <a href="HTML5_Security_Cheat_Sheet.html">
            
                    
                    HTML5 Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.29" data-path="HTTP_Strict_Transport_Security_Cheat_Sheet.html">
            
                <a href="HTTP_Strict_Transport_Security_Cheat_Sheet.html">
            
                    
                    HTTP Strict Transport Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.30" data-path="Injection_Prevention_Cheat_Sheet.html">
            
                <a href="Injection_Prevention_Cheat_Sheet.html">
            
                    
                    Injection Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.31" data-path="Injection_Prevention_Cheat_Sheet_in_Java.html">
            
                <a href="Injection_Prevention_Cheat_Sheet_in_Java.html">
            
                    
                    Injection Prevention  in Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.32" data-path="Input_Validation_Cheat_Sheet.html">
            
                <a href="Input_Validation_Cheat_Sheet.html">
            
                    
                    Input Validation 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.33" data-path="Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html">
            
                <a href="Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html">
            
                    
                    Insecure Direct Object Reference Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.34" data-path="JAAS_Cheat_Sheet.html">
            
                <a href="JAAS_Cheat_Sheet.html">
            
                    
                    JAAS 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.35" data-path="JSON_Web_Token_Cheat_Sheet_for_Java.html">
            
                <a href="JSON_Web_Token_Cheat_Sheet_for_Java.html">
            
                    
                    JSON Web Token  for Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.36" data-path="Key_Management_Cheat_Sheet.html">
            
                <a href="Key_Management_Cheat_Sheet.html">
            
                    
                    Key Management 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.37" data-path="LDAP_Injection_Prevention_Cheat_Sheet.html">
            
                <a href="LDAP_Injection_Prevention_Cheat_Sheet.html">
            
                    
                    LDAP Injection Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.38" data-path="Logging_Cheat_Sheet.html">
            
                <a href="Logging_Cheat_Sheet.html">
            
                    
                    Logging 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.39" data-path="Mass_Assignment_Cheat_Sheet.html">
            
                <a href="Mass_Assignment_Cheat_Sheet.html">
            
                    
                    Mass Assignment 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.40" data-path="OS_Command_Injection_Defense_Cheat_Sheet.html">
            
                <a href="OS_Command_Injection_Defense_Cheat_Sheet.html">
            
                    
                    OS Command Injection Defense 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.41" data-path="PHP_Configuration_Cheat_Sheet.html">
            
                <a href="PHP_Configuration_Cheat_Sheet.html">
            
                    
                    PHP Configuration 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.42" data-path="Password_Storage_Cheat_Sheet.html">
            
                <a href="Password_Storage_Cheat_Sheet.html">
            
                    
                    Password Storage 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.43" data-path="Pinning_Cheat_Sheet.html">
            
                <a href="Pinning_Cheat_Sheet.html">
            
                    
                    Pinning 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.44" data-path="Protect_FileUpload_Against_Malicious_File.html">
            
                <a href="Protect_FileUpload_Against_Malicious_File.html">
            
                    
                    Protect FileUpload Against Malicious File
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.45" data-path="Query_Parameterization_Cheat_Sheet.html">
            
                <a href="Query_Parameterization_Cheat_Sheet.html">
            
                    
                    Query Parameterization 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.46" data-path="REST_Assessment_Cheat_Sheet.html">
            
                <a href="REST_Assessment_Cheat_Sheet.html">
            
                    
                    REST Assessment 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.47" data-path="REST_Security_Cheat_Sheet.html">
            
                <a href="REST_Security_Cheat_Sheet.html">
            
                    
                    REST Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.48" data-path="Ruby_on_Rails_Cheatsheet.html">
            
                <a href="Ruby_on_Rails_Cheatsheet.html">
            
                    
                    Ruby on Rails Cheatsheet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.49" data-path="SAML_Security_Cheat_Sheet.html">
            
                <a href="SAML_Security_Cheat_Sheet.html">
            
                    
                    SAML Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.50" data-path="SQL_Injection_Prevention_Cheat_Sheet.html">
            
                <a href="SQL_Injection_Prevention_Cheat_Sheet.html">
            
                    
                    SQL Injection Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.51" data-path="Securing_Cascading_Style_Sheets_Cheat_Sheet.html">
            
                <a href="Securing_Cascading_Style_Sheets_Cheat_Sheet.html">
            
                    
                    Securing Cascading Style Sheets 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.52" data-path="Session_Management_Cheat_Sheet.html">
            
                <a href="Session_Management_Cheat_Sheet.html">
            
                    
                    Session Management 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.53" data-path="TLS_Cipher_String_Cheat_Sheet.html">
            
                <a href="TLS_Cipher_String_Cheat_Sheet.html">
            
                    
                    TLS Cipher String 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.54" data-path="Third_Party_Javascript_Management_Cheat_Sheet.html">
            
                <a href="Third_Party_Javascript_Management_Cheat_Sheet.html">
            
                    
                    Third Party Javascript Management 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.55" data-path="Threat_Modeling_Cheat_Sheet.html">
            
                <a href="Threat_Modeling_Cheat_Sheet.html">
            
                    
                    Threat Modeling 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.56" data-path="Transaction_Authorization_Cheat_Sheet.html">
            
                <a href="Transaction_Authorization_Cheat_Sheet.html">
            
                    
                    Transaction Authorization 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.57" data-path="Transport_Layer_Protection_Cheat_Sheet.html">
            
                <a href="Transport_Layer_Protection_Cheat_Sheet.html">
            
                    
                    Transport Layer Protection 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.58" data-path="Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html">
            
                <a href="Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html">
            
                    
                    Unvalidated Redirects and Forwards 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.59" data-path="User_Privacy_Protection_Cheat_Sheet.html">
            
                <a href="User_Privacy_Protection_Cheat_Sheet.html">
            
                    
                    User Privacy Protection 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.60" data-path="Virtual_Patching_Cheat_Sheet.html">
            
                <a href="Virtual_Patching_Cheat_Sheet.html">
            
                    
                    Virtual Patching 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.61" data-path="Vulnerability_Disclosure_Cheat_Sheet.html">
            
                <a href="Vulnerability_Disclosure_Cheat_Sheet.html">
            
                    
                    Vulnerability Disclosure 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.62" data-path="Vulnerable_Dependency_Management_Cheat_Sheet.html">
            
                <a href="Vulnerable_Dependency_Management_Cheat_Sheet.html">
            
                    
                    Vulnerable Dependency Management 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.63" data-path="Web_Service_Security_Cheat_Sheet.html">
            
                <a href="Web_Service_Security_Cheat_Sheet.html">
            
                    
                    Web Service Security 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.64" data-path="XML_External_Entity_Prevention_Cheat_Sheet.html">
            
                <a href="XML_External_Entity_Prevention_Cheat_Sheet.html">
            
                    
                    XML External Entity Prevention 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.65" data-path="XML_Security_Cheat_Sheet.html">
            
                <a href="XML_Security_Cheat_Sheet.html">
            
                    
                    XML Security 
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Cross-Site Request Forgery Prevention </a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="introduction"><a name="introduction" class="plugin-anchor" href="#introduction"><i class="fa fa-link" aria-hidden="true"></i></a>Introduction</h1>
<p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" target="_blank">Cross-Site Request Forgery (CSRF)</a>) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user&#x2019;s web browser to perform an unwanted action on a trusted site when the user is authenticated. A CSRF attack works because browser requests automatically include any credentials associated with the site, such as the user&apos;s session cookie, IP address, etc. Therefore, if the user is authenticated to the site, the site cannot distinguish between the forged or legitimate request sent by the victim. We would need a token/identifier that is not accessible to attacker and would not be sent along (like cookies) with forged requests that attacker initiates. For more information on CSRF, see OWASP <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" target="_blank">Cross-Site Request Forgery (CSRF) page</a>).</p>
<p>The impact of a successful CSRF attack is limited to the capabilities exposed by the vulnerable application. For example, this attack could result in a transfer of funds, changing a password, or making a purchase with the user&#x2019;s credentials. In effect, CSRF attacks are used by an attacker to make a target system perform a function via the target&apos;s browser, without the user&#x2019;s knowledge, at least until the unauthorized transaction has been committed.</p>
<p>Impacts of successful CSRF exploits vary greatly based on the privileges of each victim. When targeting a normal user, a successful CSRF attack can compromise end-user data and their associated functions. If the targeted end user is an administrator account, a CSRF attack can compromise the entire web application. Using social engineering, an attacker can embed malicious HTML or JavaScript code into an email or website to request a specific &apos;task URL&apos;. The task then executes with or without the user&apos;s knowledge, either directly or by using a Cross-Site Scripting flaw. For example, see <a href="https://en.wikipedia.org/wiki/Samy_(computer_worm" target="_blank">Samy MySpace Worm</a>).</p>
<h1 id="whats-new"><a name="whats-new" class="plugin-anchor" href="#whats-new"><i class="fa fa-link" aria-hidden="true"></i></a>What&apos;s new?</h1>
<p>If you have seen OWASP <a href="https://www.owasp.org/index.php?title=Cross-Site_Request_Forgery_(CSRF" target="_blank">old CSRF prevention cheat sheets</a>_Prevention_Cheat_Sheet&amp;action=history), you can observe that a lot has changed in this newer version. One of the major changes is that the &#x201C;Verifying same origin with standard headers&#x201D; CSRF defense has been moved to the Defense in Depth section, whereas token based mitigation moved to the Primary Defense section (technical reasons for this switch were added under respective sections). Multiple new sections (HMAC based token protection, auto CSRF mitigation techniques, login CSRF, not so popular CSRF mitigations and CSRF mitigation myths) were added besides adding new content, removing obsolete content to the existing sections. Security issues/caveats associated with each mitigation were also included.</p>
<h1 id="warning-no-cross-site-scripting-xss-vulnerabilities"><a name="warning-no-cross-site-scripting-xss-vulnerabilities" class="plugin-anchor" href="#warning-no-cross-site-scripting-xss-vulnerabilities"><i class="fa fa-link" aria-hidden="true"></i></a>Warning: No Cross-Site Scripting (XSS) Vulnerabilities</h1>
<p><a href="https://www.owasp.org/index.php/Cross-Site_Scripting" target="_blank">Cross-Site Scripting</a> is not necessary for CSRF to work. However, any cross-site scripting vulnerability can be used to defeat all CSRF mitigation techniques available in the market today (except mitigation techniques that involve user interaction and described later in this cheatsheet). This is because an XSS payload can simply read any page on the site using an XMLHttpRequest (direct DOM access can be done, if on same page) and obtain the generated token from the response, and include that token with a forged request.  This technique is exactly how the <a href="https://en.wikipedia.org/wiki/Samy_(computer_worm" target="_blank">MySpace (Samy) worm</a>) defeated MySpace&apos;s anti-CSRF defenses in 2005, which enabled the worm to propagate.</p>
<p>It is imperative that no XSS vulnerabilities are present to ensure that CSRF defenses can&apos;t be circumvented. Please see the OWASP <a href="Cross_Site_Scripting_Prevention_Cheat_Sheet.html">XSS Prevention Cheat Sheet</a> for detailed guidance on how to prevent XSS flaws.</p>
<h1 id="resources-that-need-to-be-protected-from-csrf-vulnerability"><a name="resources-that-need-to-be-protected-from-csrf-vulnerability" class="plugin-anchor" href="#resources-that-need-to-be-protected-from-csrf-vulnerability"><i class="fa fa-link" aria-hidden="true"></i></a>Resources that need to be protected from CSRF vulnerability</h1>
<p>The following list assumes that you are not violating <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1" target="_blank">RFC2616</a>, section 9.1.1, by using GET requests for state changing operations.</p>
<p><strong>Note:</strong> If for any reason you violate, you would also need to protect those resources, which is mostly achieved with default <code>form</code> <code>tag</code> <code>[GET method]</code>, <code>href</code>, and <code>src</code> attributes.</p>
<ul>
<li>Form tags with POST</li>
<li>Ajax/XHR calls</li>
</ul>
<h1 id="csrf-defense-recommendations-summary"><a name="csrf-defense-recommendations-summary" class="plugin-anchor" href="#csrf-defense-recommendations-summary"><i class="fa fa-link" aria-hidden="true"></i></a>CSRF Defense Recommendations Summary</h1>
<p>We recommend token based CSRF defense (either stateful/stateless) as a primary defense to mitigate CSRF in your applications. Only for highly sensitive operations, we also recommend a user interaction based protection (either re-authentication/one-time token, detailed in section 6.5) along with token based mitigation.</p>
<p>As a defense-in-depth measure, consider implementing one mitigation from Defense in Depth Mitigations section (you can choose the mitigation that fits your ecosystem considering the issues mentioned under them). These defense-in-depth mitigation techniques are not recommended to be used by themselves (without token based mitigation) for mitigating CSRF in your applications.</p>
<h1 id="primary-defense-technique"><a name="primary-defense-technique" class="plugin-anchor" href="#primary-defense-technique"><i class="fa fa-link" aria-hidden="true"></i></a>Primary Defense Technique</h1>
<h2 id="token-based-mitigation"><a name="token-based-mitigation" class="plugin-anchor" href="#token-based-mitigation"><i class="fa fa-link" aria-hidden="true"></i></a>Token Based Mitigation</h2>
<p>This defense is one of the most popular and recommended methods to mitigate CSRF. It can be achieved either with state (synchronizer token pattern) or stateless (encrypted/hash based token pattern). See section 4.3 on how to mitigate login CSRF in your applications. For all the mitigation&apos;s, it is implicit that general security principles should be adhered</p>
<ul>
<li>Strong encryption/HMAC functions should be adhered to.</li>
</ul>
<p><strong>Note:</strong> You can select any algorithm per your organizational needs. We recommend AES256-GCM for encryption and SHA256/512 for HMAC.</p>
<ul>
<li>Strict key rotation and token lifetime policies should be maintained. Policies can be set according to your organizational needs. Generic key management guidance from OWASP can be found <a href="Key_Management_Cheat_Sheet.html">here</a>.</li>
</ul>
<h3 id="synchronizer-token-pattern"><a name="synchronizer-token-pattern" class="plugin-anchor" href="#synchronizer-token-pattern"><i class="fa fa-link" aria-hidden="true"></i></a>Synchronizer Token Pattern</h3>
<p>Any state changing operation requires a secure random token (e.g., CSRF token) to prevent CSRF attacks. A CSRF token should be unique per user session, large random value, and also generated by a cryptographically secure random number generator. The CSRF token is added as a hidden field for forms, headers/parameters for AJAX calls (It is recommended to add in parameter than in header. If you need to add it to header, it is better to make sure that the token header is not being logged at your server) and within the URL if the state changing operation occurs via a GET. See &quot;Disclosure of Token in URL&quot; section below. The server rejects the requested action if the CSRF token fails validation.</p>
<p>Inserting the CSRF token in the HTTP request header via JavaScript is considered more secure than adding the token in the hidden field form parameter. In this situation, even if the CSRF token is weak, predictable or leaked but still an attacker cannot forge the POST request directly by setting the custom request header through XMLHttpRequest. As per the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests" target="_blank">MDN documentation</a> when the attacker tries to set any custom header through any XMLHttpRequest, the browser sends the OPTIONS (pre-flight) request. Moreover, when the attacker tries to spoof the header through flash, the browser initiates the GET request for crossdomain.xml. In both cases, the browser prevents the forged request to be sent.</p>
<p>In order to facilitate a &quot;transparent but visible&quot; CSRF solution, developers are encouraged to adopt a pattern similar to <a href="http://www.corej2eepatterns.com/Design/PresoDesign.htm" target="_blank">Synchronizer Token Pattern</a> (The original intention of this synchronizer token pattern was to detect duplicate submissions in forms). The synchronizer token pattern requires the generation of random &quot;challenge&quot; tokens that are associated with the user&apos;s current session. These challenge tokens are then inserted within the HTML forms and calls associated with sensitive server-side operations. It is the responsibility of the server application to verify the existence and correctness of this token. By including a challenge token with each request, the developer has a strong control to verify that the user actually intended to submit the desired requests. Inclusion of a required security token in HTTP requests associated with sensitive business functions helps mitigate CSRF attacks as successful exploitation assumes the attacker knows the randomly generated token for the target victim&apos;s session.</p>
<p><strong>Note:</strong> These tokens aren&#x2019;t like cookies that are automatically sent with forged requests made from your browser from the attacker website.</p>
<p>This is analogous to the attacker being able to guess the target victim&apos;s session identifier.</p>
<p>The following describes a general approach to incorporate challenge tokens within the request.</p>
<p>When a Web application formulates a request, the application should include a hidden input parameter with a common name such as &quot;CSRFToken&quot; (for forms)/ as header/parameter value for Ajax calls. The value of this token must be randomly generated such that it cannot be guessed by an attacker. Consider leveraging the java.security.SecureRandom class for Java applications to generate a sufficiently long random token. Alternative generation algorithms include the use of 256-bit BASE64 encoded hashes. Developers that choose this generation algorithm must make sure that there is randomness and uniqueness utilized in the data that is hashed to generate the random token.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/transfer.do&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CSRFToken&quot;</span>
<span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OWY4NmQwODE4ODRjN2Q2NTlhMmZlYWEwYzU1YWQwMTVhM2JmNGYxYjJiMGI4MjJjZDE1ZDZMGYwMGEwOA==&quot;</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>In general, developers need only generate this token once for the current session. After initial generation of this token, the value is stored in the session and is used for each subsequent request until the session expires. When a request is issued by the end-user, the server-side component must verify the existence and validity of the token in the request compared to the token found in the user session. If the token was not found within the request, or the value provided does not match the value within the user session, then the request should be aborted, and the event logged as a potential CSRF attack in progress.</p>
<p>To further enhance the security of this proposed design, consider randomizing the CSRF token parameter name and/or value for each request. Implementing this approach results in the generation of per-request tokens as opposed to per-session tokens. This is more secure than per-session tokens as the time range for an attacker to exploit the stolen tokens is minimal. However, this may result in usability concerns. For example, the &quot;Back&quot; button browser capability is often hindered as the previous page may contain a token that is no longer valid. Interaction with this previous page will result in a CSRF false positive security event at the server. Few applications that need high security typically implement this approach (such as banks). You have to check what suits your needs. Regardless of the approach taken, developers are encouraged to protect the CSRF token the same way they protect authenticated session identifiers, such as the use of TLS.</p>
<p><strong>Existing Synchronizer Implementations</strong></p>
<p>Synchronizer token defenses have been built into many frameworks, so we strongly recommend using them first when they are available. External components that add CSRF defenses to existing applications are also recommended. OWASP has the following:</p>
<ul>
<li>For Java: OWASP <a href="https://www.owasp.org/index.php/CSRF_Guard" target="_blank">CSRF Guard</a></li>
<li>For PHP and Apache: <a href="https://www.owasp.org/index.php/CSRFProtector_Project" target="_blank">CSRFProtector Project</a></li>
</ul>
<p><strong>Disclosure of Token in URL</strong></p>
<p>Some implementations of synchronizer tokens include the challenge token in GET (URL) requests as well as POST requests. This is often implemented as a result of sensitive server-side operations being invoked as a result of embedded links in the page or other general design patterns. These patterns are often implemented without knowledge of CSRF and an understanding of CSRF prevention design strategies. While this control does help mitigate the risk of CSRF attacks, the unique per-session token is being exposed for GET requests. CSRF tokens in GET requests are potentially leaked at several locations: browser history, log files, network appliances that make a point to log the first line of an HTTP request, and Referer headers if the protected site links to an external site. In the latter case (leaked CSRF token due to the Referer header being parsed by a linked site), it is trivially easy for the linked site to launch a CSRF attack on the protected site, and they will be able to target this attack very effectively, since the Referer header tells them the site as well as the CSRF token. The attack could be run entirely from JavaScript, so that a simple addition of a script tag to the HTML of a site can launch an attack (whether on an originally malicious site or on a hacked site). Additionally, since HTTPS requests from HTTPS contexts will not strip the Referer header (as opposed to HTTPS to HTTP requests) CSRF token leaks via Referer can still happen on HTTPS Applications.</p>
<p>The ideal solution is to only include the CSRF token in POST requests and modify server-side actions that have state changing affect to only respond to POST requests. This is in fact what the RFC 2616 requires for GET requests. If sensitive server-side actions are guaranteed to only ever respond to POST requests, then there is no need to include the token in GET requests.</p>
<p>In most JavaEE web applications, however, HTTP method scoping is rarely ever utilized when retrieving HTTP parameters from a request. Calls to <code>HttpServletRequest.getParameter</code> will return a parameter value regardless if it was a GET or POST. This is not to say HTTP method scoping cannot be enforced. It can be achieved if a developer explicitly overrides <code>doPost()</code> in the <code>HttpServlet</code> class or leverages framework specific capabilities such as the <code>AbstractFormController</code> class in Spring.</p>
<p>For these cases, attempting to retrofit this pattern in existing applications requires significant development time and cost, and as a temporary measure it may be better to pass CSRF tokens in the URL. Once the application has been fixed to respond to HTTP GET and POST verbs correctly, CSRF tokens for GET requests should be turned off.</p>
<h3 id="encryption-based-token-pattern"><a name="encryption-based-token-pattern" class="plugin-anchor" href="#encryption-based-token-pattern"><i class="fa fa-link" aria-hidden="true"></i></a>Encryption based Token Pattern</h3>
<p>The Encrypted Token Pattern leverages an encryption, rather than comparison method of Token-validation. It is most suitable for applications that do not want to maintain any state at server side.</p>
<p>After successful authentication, the server generates a unique token comprised of the user&apos;s ID, a timestamp value and a <a href="http://en.wikipedia.org/wiki/Cryptographic_nonce" target="_blank">nonce</a>, using a unique key available only on the server. This token is returned to the client and embedded in a hidden field for forms, in the request-header/parameter for AJAX requests. On receipt of this request, the server reads and decrypts the token value with the same key used to create the token. Inability to correctly decrypt suggest an intrusion attempt. Once decrypted, the UserId and timestamp contained within the token are validated; the UserId is compared against the currently logged in user, and the timestamp is compared against the current time.</p>
<p>On successful token-decryption, the server has access to parsed values, ideally in the form of <a href="http://en.wikipedia.org/wiki/Claims-based_identity" target="_blank">claims</a>. These claims are processed by comparing the UserId claim to any potentially stored UserId (in a Cookie or Session variable, if the site already contains a means of authentication). The Timestamp is validated against the current time, preventing replay attacks. Alternatively, in the case of a CSRF attack, the server will be unable to decrypt the poisoned token, and can block and log the attack.</p>
<p>This technique addresses some of the shortfalls in other stateless approaches, such as the need to store data in a Cookie, circumnavigating the Cookie-subdomain and HTTPONLY issues.</p>
<h3 id="hmac-based-token-pattern"><a name="hmac-based-token-pattern" class="plugin-anchor" href="#hmac-based-token-pattern"><i class="fa fa-link" aria-hidden="true"></i></a>HMAC Based Token Pattern</h3>
<p><a href="https://en.wikipedia.org/wiki/HMAC" target="_blank">HMAC (hash-based message authentication code)</a> is a cryptographic function that helps to guarantee integrity and authentication of a message. It is another way that CSRF mitigation can be achieved without maintaining any state at the server and is similar to an encryption token-based pattern with two main differences:</p>
<ul>
<li>Uses a strong HMAC function instead of an encryption function to generate the token</li>
<li>Includes an additional field called &#x2018;operation&#x2019; that would indicate the purpose of the operation for which you are including the CSRF token (may it be form tag/ajax call)</li>
</ul>
<p>Example:</p>
<pre><code class="lang-text">oneclickpurchase (or) buy/asin=SDFH&amp;category=2&amp;quantity=3)
</code></pre>
<p><strong>Note:</strong> Fields mentioned in encryption token pattern (user&apos;s ID, a timestamp value and a nonce) are included.</p>
<p>The operation field helps in mitigating the fact that the hash function generates the same value irrespective of multiple iterations (unlike strong encryption functions that generate different values when they are encrypted each time). So, it would help in avoiding having repeated token values across your application. Nonce field serves the same purpose as in encrypted token pattern (i.e., to avoid rare collisions due to weak cryptographic functions and acts as a defense-in-depth measure).</p>
<p>Generate the token using HMAC including all four fields mentioned previously (user&apos;s ID, a timestamp value, nonce, and operation) and then include it in hidden fields for form tags, headers/parameters for ajax calls. Once you receive the HMAC from the client in the requests, re-generate HMAC with the same fields that you used to generate it, and then verify that the HMAC you re-generated matches the HMAC received from the client. If it does, it is a legitimate user request and if it does not, flag it as a CSRF intrusion and alert your incident response teams. Because an attacker has no visibility into the key used for generating the hash fields used in generating it, there is no way for them to re-generate it to use in forged request.</p>
<h2 id="auto-csrf-mitigation-techniques"><a name="auto-csrf-mitigation-techniques" class="plugin-anchor" href="#auto-csrf-mitigation-techniques"><i class="fa fa-link" aria-hidden="true"></i></a>Auto CSRF Mitigation Techniques</h2>
<p>Though the technique of mitigating tokens is widely used (stateful with synchronizer token and stateless with encrypted/HMAC token), the major problem associated with these techniques is the human tendency to forget things at times. If a developer forgets to add the token to any state changing operation, they are making the application vulnerable to CSRF. To avoid this, you can try to automate the process of adding tokens to CSRF vulnerable resources (mentioned earlier in this document). You can achieve this by doing the following:</p>
<ul>
<li>Write wrappers (that would auto add tokens when used) around default form tags/ajax calls and educate your developers to use those wrappers instead of standard tags. Though this approach is better than depending purely on developers to add tokens, it still is vulnerable to the issue of human tendency to forget things. <a href="https://docs.spring.io/spring-security/site/docs/3.2.0.CI-SNAPSHOT/reference/html/csrf.html" target="_blank">Spring Security</a> uses this technique to add CSRF tokens by default when a custom <code>&lt;form:form&gt;</code> tag is used, you can opt to use after verifying that its enabled and properly configured in the Spring Security version you are using.</li>
<li>Write a hook (that would capture the traffic and add tokens to CSRF vulnerable resources before rendering to customers) in your organizational web rendering frameworks. Because it is hard to analyze when a particular response is doing any state change (and thus needing a token), you might want to include tokens in all CSRF vulnerable resources (ex: include tokens in all POST responses). This is one recommended approach, but you need to consider the performance costs it might incur.</li>
<li>Get the tokens automatically added on the client side when the page is being rendered in user&#x2019;s browser, with help of a client side script (this approach is used by <a href="https://www.owasp.org/index.php/CSRF_Guard" target="_blank">CSRF Guard</a>). You need to consider any possible JavaScript hijacking attacks.</li>
</ul>
<p>We recommend researching if the framework you are using has an option to achieve CSRF protection by default before trying to build your custom auto tokening system. For example, .NET has an <a href="https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-2.1" target="_blank">in-built protection</a> that adds token to CSRF vulnerable resources. You are responsible for proper configuration (such as key management and token management) before using these in-built CSRF protections that do auto tokening to CSRF vulnerable resources.</p>
<h2 id="login-csrf"><a name="login-csrf" class="plugin-anchor" href="#login-csrf"><i class="fa fa-link" aria-hidden="true"></i></a>Login CSRF</h2>
<p>Most developers tend to ignore CSRF vulnerability on login forms as they assume that CSRF would not be applicable on login forms because user is not authenticated at that stage. That assumption is false. CSRF vulnerability can still occur on login forms where the user is not authenticated, but the impact/risk view for it is quite different from the impact/risk view of a general CSRF vulnerability (when a user is authenticated).</p>
<p>With a CSRF vulnerability on login form, an attacker can make a victim login as them and learn behavior from their searches. For more information about login CSRF and other risks, see section 3 of <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">this</a> paper.</p>
<p>Login CSRF can be mitigated by creating pre-sessions (sessions before a user is authenticated) and including tokens in login form. You can use any of the techniques mentioned above to generate tokens. Pre-sessions can be transitioned to real sessions once the user is authenticated. This technique is described in <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">Robust Defenses for Cross-Site Request Forgery section 4.1</a>.</p>
<p>If sub-domains under your master domain are treated as not trusty in your threat model, it is difficult to mitigate login CSRF. A strict subdomain and path level referrer header (because most login pages are served on HTTPS - no stripping of referrer - and are also linked from home pages) validation (detailed in section 6.1) can be used in these cases for mitigating CSRF on login forms to an extent.</p>
<h1 id="defense-in-depth-techniques"><a name="defense-in-depth-techniques" class="plugin-anchor" href="#defense-in-depth-techniques"><i class="fa fa-link" aria-hidden="true"></i></a>Defense In Depth Techniques</h1>
<h2 id="verifying-origin-with-standard-headers"><a name="verifying-origin-with-standard-headers" class="plugin-anchor" href="#verifying-origin-with-standard-headers"><i class="fa fa-link" aria-hidden="true"></i></a>Verifying origin with standard headers</h2>
<p>This defense technique is specifically proposed in section 5.0 of <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">Robust Defenses for Cross-Site Request Forgery</a>. This paper proposes the first creation of the Origin header and its use as a CSRF defense mechanism.</p>
<p>There are two steps to this mitigation, both of which rely on examining an HTTP request header value.</p>
<ol>
<li><p>Determining the origin the request is coming from (source origin). Can be done via Origin and/or referer header.</p>
</li>
<li><p>Determining the origin the request is going to (target origin).</p>
</li>
</ol>
<p>At server side we verify if both of them match. If they do, we accept the request as legitimate (meaning it&#x2019;s the same origin request) and if they don&#x2019;t, we discard the request (meaning that the request originated from cross-domain). Reliability on these headers comes from the fact that they cannot be altered programmatically (using JavaScript in an XSS) as they fall under <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name" target="_blank">forbidden headers</a> list (i.e., only browsers can set them).</p>
<h3 id="identifying-source-origin-via-originreferer-header"><a name="identifying-source-origin-via-originreferer-header" class="plugin-anchor" href="#identifying-source-origin-via-originreferer-header"><i class="fa fa-link" aria-hidden="true"></i></a>Identifying Source Origin (via Origin/Referer header)</h3>
<p><strong>Checking the Origin Header</strong></p>
<p>If the Origin header is present, verify that its value matches the target origin. Unlike the Referer, the Origin header will be present in HTTP requests that originate from an HTTPS URL.</p>
<p><strong>Checking the Referer Header</strong></p>
<p>If the Origin header is not present, verify the hostname in the Referer header matches the target origin. This method of CSRF mitigation is also commonly used with unauthenticated requests, such as requests made prior to establishing a session state, which is required to keep track of a synchronization token.</p>
<p>In both cases, make sure the target origin check is strong. For example, if your site is <code>site.com</code> make sure <code>site.com.attacker.com</code> does not pass your origin check (i.e., match through the trailing / after the origin to make sure you are matching against the entire origin).</p>
<p>If neither of these headers are present, you can either accept or block the request. We recommend <strong>blocking</strong>. Alternatively, you might want to log all such instances, monitor their use cases/behavior, and then start blocking requests only after you get enough confidence.</p>
<h3 id="identifying-the-target-origin"><a name="identifying-the-target-origin" class="plugin-anchor" href="#identifying-the-target-origin"><i class="fa fa-link" aria-hidden="true"></i></a>Identifying the Target Origin</h3>
<p>You might think it&#x2019;s easy to determine the target origin, but it&#x2019;s frequently not. The first thought is to simply grab the target origin (i.e., its hostname and port <code>#</code>) from the URL in the request. However, the application server is frequently sitting behind one or more proxies and the original URL is different from the URL the app server actually receives. If your application server is directly accessed by its users, then using the origin in the URL is fine and you&apos;re all set.</p>
<p>If you are behind a proxy, there are a number of options to consider.</p>
<ul>
<li><p><strong>Configure your application to simply know its target origin:</strong> It&#x2019;s your application, so you can find its target origin and set that value in some server configuration entry. This would be the most secure approach as its defined server side, so it is a trusted value. However, this might be problematic to maintain if your application is deployed in many places, e.g., dev, test, QA, production, and possibly multiple production instances. Setting the correct value for each of these situations might be difficult, but if you can do it via some central configuration and providing your instances to grab value from it, that&apos;s great! (<strong>Note:</strong> Make sure the centralized configuration store is maintained securely because major part of your CSRF defense depends on it.)</p>
</li>
<li><p><strong>Use the Host header value:</strong> If you prefer that the application find its own target so it doesn&apos;t have to be configured for each deployed instance, we recommend using the Host family of headers. The Host header&apos;s purpose is to contain the target origin of the request. But, if your app server is sitting behind a proxy, the Host header value is most likely changed by the proxy to the target origin of the URL behind the proxy, which is different than the original URL. This modified Host header origin won&apos;t match the source origin in the original Origin or Referer headers.</p>
</li>
<li><p><strong>Use the X-Forwarded-Host header value:</strong> To avoid the issue of proxy altering the host header, there is another header called X-Forwarded-Host, whose purpose is to contain the original Host header value the proxy received. Most proxies will pass along the original Host header value in the X-Forwarded-Host header. So that header value is likely to be the target origin value you need to compare to the source origin in the Origin or Referer header.</p>
</li>
</ul>
<p>This mitigation in earlier versions of the CSRF Cheat Sheet is treated as a primary defense. For reasons mentioned below, it is now moved to the Defense in Depth section.</p>
<p>As it&#x2019;s implicit, this mitigation would work properly when origin or referrer headers are present in the requests. Though these headers are included <strong>majority</strong> of the time, there are few use cases where they are not included (most of them are for legitimate reasons to safeguard users privacy/to tune to browsers ecosystem). The following lists some use cases:</p>
<ul>
<li>Internet Explorer 11 does not add the Origin header on a CORS request across sites of a trusted zone. The Referer header will remain the only indication of the UI origin. See the following references in stackoverflow <a href="https://stackoverflow.com/questions/20784209/internet-explorer-11-does-not-add-the-origin-header-on-a-cors-request" target="_blank">here</a> and <a href="https://github.com/silverstripe/silverstripe-graphql/issues/118" target="_blank">here</a>.</li>
<li>In an instance following a <a href="https://stackoverflow.com/questions/22397072/are-there-any-browsers-that-set-the-origin-header-to-null-for-privacy-sensitiv" target="_blank">302 redirect cross-origin</a>, Origin is not included in the redirected request because that may be considered sensitive information that should not be sent to the other origin.</li>
<li>There are some <a href="https://wiki.mozilla.org/Security/Origin#Privacy-Sensitive_Contexts" target="_blank">privacy contexts</a> where Origin is set to &#x201C;null&#x201D; For example, see the following <a href="https://www.google.com/search?q=origin+header+sent+null+value+site%3Astackoverflow.com&amp;oq=origin+header+sent+null+value+site%3Astackoverflow.com" target="_blank">here</a>.</li>
<li>Origin header is included for all cross origin requests but for same origin requests, in most browsers it is only included in POST/DELETE/PUT <strong>Note:</strong> Although it is not ideal, many developers use GET requests to do state changing operations.</li>
<li>Referer header is no exception. There are multiple use cases where referrer header is omitted as well (<a href="https://stackoverflow.com/questions/6880659/in-what-cases-will-http-referer-be-empty" target="_blank">1</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer" target="_blank">2</a>, <a href="https://en.wikipedia.org/wiki/HTTP_referer#Referer_hiding" target="_blank">3</a>, <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">4</a> and <a href="https://www.google.com/search?q=referrer+header+sent+null+value+site:stackoverflow.com" target="_blank">5</a>). Load balancers, proxies and embedded network devices are also well known to strip the referrer header due to privacy reasons in logging them.</li>
</ul>
<p>Usually, a minor percentage of traffic does fall under above categories (<a href="http://homakov.blogspot.com/2012/04/playing-with-referer-origin-disquscom.html" target="_blank">1-2%</a>) and no enterprise would want to loose even this minor % of traffic. One of the popular technique used across Internet to make this technique more usable is to accept the request if the Origin/referrer matches your configured list of domains &quot;OR&quot; a null value (Examples <a href="http://homakov.blogspot.com/2012/04/playing-with-referer-origin-disquscom.html" target="_blank">here</a>. null value is to cover the edge cases mentioned above where these headers are not sent). Please note that, attackers can use it to exploit CSRF using the edge cases but many prefer to deploy this technique it as a defense in depth measure because of minor effort involved in creating it.</p>
<p>As an alternative, you can write exceptions for each of the edge cases observed in your environment but that requires significant effort and is a long term on-going commitment with minimal 100% success guarantee. This CSRF defense relies on browser behavior that can change at times. For example, when new privacy contexts are discovered, under which situations you have to keep your validation logic updated, where as in token based mitigation, you have full control on the CSRF mitigation. If browsers alter CSRF tokens, they are literally changing the HTML content on rendering pages (which no browser would ever want to do!).</p>
<p>When there is an XSS vulnerability on a page of an application protected with Origin and/or Referrer header, the level of effort required to exploit state changing operations (that are typically vulnerable to CSRF) on other pages is very easy (grab the parameters and forge a request, as Origin and Referrer header is included by default by browsers) than compared to token based mitigation (where attacker needs to download the target page, parse the DOM for the token, construct a forge request, and send it to server).</p>
<p><strong>Note:</strong> Although the concept of origin header stemmed from <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">this</a> paper that references robust CSRF defenses, initial <a href="https://tools.ietf.org/html/rfc6454" target="_blank">origin header RFC</a> does not reference to mitigate CSRF in any way (another <a href="https://tools.ietf.org/id/draft-abarth-origin-03.html" target="_blank">draft version</a> does, however).</p>
<h2 id="double-submit-cookie"><a name="double-submit-cookie" class="plugin-anchor" href="#double-submit-cookie"><i class="fa fa-link" aria-hidden="true"></i></a>Double Submit Cookie</h2>
<p>If maintaining the state for CSRF token at server side is problematic, an alternative defense is to use the double submit cookie technique. This technique is easy to implement and is stateless. In this technique, we send a random value in both a cookie and as a request parameter, with the server verifying if the cookie value and request value match. When a user visits (even before authenticating to prevent login CSRF), the site should generate a (cryptographically strong) pseudorandom value and set it as a cookie on the user&apos;s machine separate from the session identifier. The site then requires that every transaction request include this pseudorandom value as a hidden form value (or other request parameter/header). If both of them match at server side, the server accepts it as legitimate request and if they don&#x2019;t, it would reject the request.</p>
<p>There&#x2019;s a belief that this technique would work because a cross origin attacker cannot read any data sent from the server or modify cookie values, per the same-origin policy. This means that while an attacker can force a victim to send any value with a malicious CSRF request, the attacker will be unable to modify or read the value stored in the cookie (with which the server compares the token value).</p>
<p>There are a couple of drawbacks associated with the assumptions made here. The problem of &quot;trusting of sub domains and proper configuration of whole site in general to accept HTTPS connections only&quot;. The <a href="https://media.blackhat.com/eu-13/briefings/Lundeen/bh-eu-13-deputies-still-confused-lundeen-wp.pdf" target="_blank">Blackhat talk</a> by Rich Lundeen references these drawbacks.</p>
<p>&quot;<em>With double submit, if an attacker can write a cookie they can obviously defeat the protection. And again, writing cookies is significantly easier then reading them. The fact that cookies can be written is difficult for many people to understand. After all, doesn&apos;t the same origin policy specify that one domain cannot access cookies from another domain? However, there are two common scenarios where writing cookies across domains is possible:</em></p>
<p><em>a)   While it&apos;s true that hellokitty.marketing.example.com cannot read cookies or access the DOM from secure.example.com because of the same origin policy, hellokitty.marketing.example.com can write cookies to the parent domain (example.com), and these cookies are then consumed by secure.example.com (secure.example.com has no good way to distinguish which site set the cookie). Additionally, there are methods of forcing secure.example.com to always accept your cookie first. What this means is that XSS in hellokitty.marketing.example.com is able to overwrite cookies in secure.example.com.</em></p>
<p><em>b)   If an attacker is in the middle, they can usually force a request to the same domain over HTTP. If an application is hosted at <code>https://secure.example.com</code>, even if the cookies are set with the secure flag, a man in the middle can force connections to <code>http://secure.example.com</code> and set (overwrite) any arbitrary cookies (even though the secure flag prevents the attacker from reading those cookies). Even if the HSTS header is set on the server and the browser visiting the site supports HSTS (this would prevent a man in the middle from forcing plaintext HTTP requests) unless the HSTS header is set in a way that includes all subdomains, a man in the middle can simply force a request to a separate subdomain and overwrite cookies similar to 1. In other words, as long as <code>http://hellokitty.marketing.example.com</code> doesn&apos;t force https, then an attacker can overwrite cookies on any <code>example.com</code> subdomain.</em>&quot;</p>
<p>So, unless you are sure that your subdomains are fully secured and only accept HTTPS connections (we believe it&#x2019;s difficult to guarantee at large enterprises), you should not rely on the Double Submit Cookie technique as a primary mitigation for CSRF.</p>
<p>Scenarios a and b mentioned above are possible only if the CSRF token is not derived/tied to the session in which case an attacker can overwrite the token in the parent domain cookie with XSS in child domain. A variant of how this can be mitigated by linking token and session/auth cookie is explained below.</p>
<p>Including the token in an encrypted cookie - often within the authentication cookie - and then at the server side matching it (after decrypting authentication cookie) with the token in hidden form field or parameter/header for ajax calls mitigates both the issues mentioned above. This works because a sub domain has no way to over-write an properly crafted encrypted cookie without the necessary information such as encryption key.</p>
<h2 id="samesite-cookie-attribute"><a name="samesite-cookie-attribute" class="plugin-anchor" href="#samesite-cookie-attribute"><i class="fa fa-link" aria-hidden="true"></i></a>Samesite Cookie Attribute</h2>
<p>SameSite is a cookie attribute (similar to HTTPOnly, Secure etc.) introduced by Google to mitigate CSRF attacks. It is defined in <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7" target="_blank">this</a> Internet Draft. This attribute helps in preventing the browser from sending cookies along with cross-site requests. Possible values for this attribute are lax or strict.</p>
<p>The strict value will prevent the cookie from being sent by the browser to the target site in all cross-site browsing context, even when following a regular link. For example, for a GitHub-like website this would mean that if a logged-in user follows a link to a private GitHub project posted on a corporate discussion forum or email, GitHub will not receive the session cookie and the user will not be able to access the project. A bank website however most likely doesn&apos;t want to allow any transactional pages to be linked from external sites, so the strict flag would be most appropriate.</p>
<p>The default lax value provides a reasonable balance between security and usability for websites that want to maintain user&apos;s logged-in session after the user arrives from an external link. In the above GitHub scenario, the session cookie would be allowed when following a regular link from an external website while blocking it in CSRF-prone request methods such as POST. Only cross-site-requests that are allowed in lax mode are the ones that have top-level navigations and are also &#x201C;safe&#x201D; HTTP methods (more details <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7.1" target="_blank">here</a>).</p>
<p>Example of cookies using this attribute:</p>
<pre><code class="lang-text">Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict
Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax
</code></pre>
<p>Support for this attribute in different browsers is increasing but there are still browsers that need to adopt this. As of August 2018, SameSite attribute is on browsers used by 68.92% of Internet users (detailed statistics are <a href="https://caniuse.com/#feat=same-site-cookie-attribute" target="_blank">here</a>).</p>
<p>Though this technique seems to be efficient in mitigating CSRF attacks, it is still in early stages (in <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7" target="_blank">draft</a>) and does not have full browser support as mentioned above. Google&#x2019;s <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7" target="_blank">draft</a> also mentions a couple cases where forged requests can be simulated by attackers as same-site requests (and thus allowing to send SameSite cookies).</p>
<p>Considering the factors above, it is not recommended to be used as a primary defense. Google agrees with this stance and strongly encourages developers to deploy server-side defenses such as tokens to mitigate CSRF more fully.</p>
<h2 id="use-of-custom-request-headers"><a name="use-of-custom-request-headers" class="plugin-anchor" href="#use-of-custom-request-headers"><i class="fa fa-link" aria-hidden="true"></i></a>Use of Custom Request Headers</h2>
<p>Adding CSRF tokens, a double submit cookie and value, encrypted token, or other defense that involves changing the UI can frequently be complex or otherwise problematic. An alternate defense that is particularly well suited for AJAX/XHR endpoints is the use of a custom request header. This defense relies on the <a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank">same-origin policy (SOP)</a> restriction that only JavaScript can be used to add a custom header, and only within its origin. By default, browsers do not allow JavaScript to make cross origin requests.</p>
<p>A particularly attractive custom header and value to use is &#x201C;X-Requested-With: XMLHttpRequest&#x201D; because most JavaScript libraries already add this header to requests they generate by default. However, some do not. For example, AngularJS used to, but does not anymore. For more information, see <a href="https://github.com/angular/angular.js/commit/3a75b1124d062f64093a90b26630938558909e8d" target="_blank">their rationale</a> and how to add it back.</p>
<p>If this is the case for your system, you can simply verify the presence of this header and value on all your server side AJAX endpoints in order to protect against CSRF attacks. This approach has the double advantage of usually requiring no UI changes and not introducing any server side state, which is particularly attractive to REST services. You can always add your own custom header and value if that is preferred.</p>
<p>This defense technique is specifically discussed in section 4.3 of <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf" target="_blank">Robust Defenses for Cross-Site Request Forgery</a>. However, bypasses of this defense using Flash were documented as early as 2008 and again as recently as 2015 by Mathias Karlsson to <a href="https://hackerone.com/reports/44146" target="_blank">exploit a CSRF flaw in Vimeo</a>. Riyaz Walikar from <a href="https://appsecco.com/" target="_blank">Appsecco Labs</a> was able to exploit this even in early 2019 <a href="https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b" target="_blank">using older versions of Firefox</a> and also in some recent versions of Chrome (with a bit of <a href="https://github.com/sp1d3r/swf_json_csrf/blob/master/read.html" target="_blank">user involvement</a>). Since we cannot the control the versions of browser end user uses nor depend on it for their security, this technique is not recommended as a primary defense in measure.</p>
<p>Besides any possible future bypasses such as Flash, using a static header will make it easy to exploit other state changing operations in the application (similar to the previous explanation on why ease of exploitation is easier in origin/referrer header check than token based mitigation). Including a random token instead of static header value is more or less equal to the token based approach described in the primary defense section. Developers also need to consider that if you are using this approach in an application with both Ajax calls and form tags, this technique would only help Ajax calls in protecting from CSRF and you would still need protect <code>&lt;form&gt;</code> tags with approaches described in this document such as tokens. Setting custom headers on form tags is not possible directly. Also, CORS configuration should also be robust to make this solution work effectively (as custom headers for requests coming from other domains trigger a pre-flight CORS check).</p>
<h2 id="user-interaction-based-csrf-defense"><a name="user-interaction-based-csrf-defense" class="plugin-anchor" href="#user-interaction-based-csrf-defense"><i class="fa fa-link" aria-hidden="true"></i></a>User Interaction Based CSRF Defense</h2>
<p>While all the techniques referenced here do not require any user interaction, sometimes it&#x2019;s easier or more appropriate to involve the user in the transaction to prevent unauthorized operations (forged via CSRF or otherwise). The following are some examples of techniques that can act as strong CSRF defense when implemented correctly.</p>
<ul>
<li>Re-Authentication (password or stronger)</li>
<li>One-time Token</li>
<li>CAPTCHA</li>
</ul>
<p>While these are a very strong CSRF defense, it does create a huge impact on the user experience. For applications that are in need of high security for some operations (password change, money transfer etc.), these techniques should be used along with token based mitigation. Please note that tokens by themselves can mitigate CSRF, developers should use these techniques only to achieve additional security for their high sensitive operations.</p>
<h1 id="not-so-popular-csrf-mitigations"><a name="not-so-popular-csrf-mitigations" class="plugin-anchor" href="#not-so-popular-csrf-mitigations"><i class="fa fa-link" aria-hidden="true"></i></a>Not So Popular CSRF Mitigations</h1>
<h2 id="triple-submit-cookie"><a name="triple-submit-cookie" class="plugin-anchor" href="#triple-submit-cookie"><i class="fa fa-link" aria-hidden="true"></i></a>Triple Submit Cookie</h2>
<p>This mitigation is proposed by John Wilander in 2012 at OWASP Appsec Research. This technique adds an additional step to double submit cookie approach by verifying if the request contains two cookies with same name (please note, attacker need to write an additional cookie to bypass double submit cookie mitigation). Though it mitigates the issues discussed in bypass of double submit cookie, it introduces new problems such as cookie jar overflow (in-details and more issue details <a href="https://media.blackhat.com/eu-13/briefings/Lundeen/bh-eu-13-deputies-still-confused-lundeen-wp.pdf" target="_blank">here</a> and <a href="https://webstersprodigy.net/2012/08/03/analysis-of-john-wilanders-triple-submit-cookies/" target="_blank">here</a>). We were not able to find any real-time implementations of this mitigation so far.</p>
<h2 id="content-type-header-validation"><a name="content-type-header-validation" class="plugin-anchor" href="#content-type-header-validation"><i class="fa fa-link" aria-hidden="true"></i></a>Content-Type Header Validation</h2>
<p>This technique is better known than the triple submit cookie mitigation. In first place, this header is not designed for security (initial RFC <a href="https://tools.ietf.org/html/rfc1049" target="_blank">here</a> and later well-defined in <a href="https://www.ietf.org/rfc/rfc2045.txt" target="_blank">this</a> RFC) but only to let receiving agents know the type of data they would be handling, so that they can invoke corresponding parsers. The pre-flighting behavior of this header (pre-flight if header has value other than application/x-www-form-urlencoded, multipart/form-data, or text/plain) is what treated as a CSRF mitigation and thus forcing all requests to have a header value that would force a pre-flight (such as application/json. Server side can reject cross-origin requests with CORS/SOP during this pre-flight).</p>
<p>This approach has two main problems. One that it would mandate all requests to have a header value that would force pre-flight despite the real use case and the other that this technique is relying on a feature that is not designed for security, to mitigate a security vulnerability. When a bug was discovered in the Chrome API, browser architects even considered to removing this pre-flighting behavior. Because this header was not designed as a security control, architects can re-design it to better cater its primary purpose. In the future, there&#x2019;s a possibility that new content-type header types can be included (to better support various use-cases), which can put systems relying on this header for CSRF mitigation in trouble. For more information, see <a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2017/september/common-csrf-prevention-misconceptions/" target="_blank">Common CSRF Prevention Misconceptions</a>.</p>
<p><a href="https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b" target="_blank">This</a> article by Riyaz Walikar also talks about how this type of content-type header validation can be vulnerable to FLASH based re-direct attacks (as discussed in section 5.7, use of custom request headers)</p>
<h1 id="csrf-mitigation-myths"><a name="csrf-mitigation-myths" class="plugin-anchor" href="#csrf-mitigation-myths"><i class="fa fa-link" aria-hidden="true"></i></a>CSRF Mitigation Myths</h1>
<p>The following shows techniques presumed to be CSRF mitigations but none of them fully/actually mitigates a CSRF vulnerability.</p>
<ul>
<li><strong>CORS</strong>: CORS is a header designed to relax Same-Origin-Policy when cross-origin communication between sites is required. It is not designed, nor prevents CSRF attacks.</li>
<li><strong>Using HTTPS</strong>: Using HTTPS has nothing to do with the protection from CSRF attacks. Resources that are under HTTPS are still vulnerable to CSRF if proper CSRF mitigations described above are not included.</li>
<li>More myths can be found <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" target="_blank">here</a>).</li>
</ul>
<h1 id="personal-safety-csrf-tips-for-users"><a name="personal-safety-csrf-tips-for-users" class="plugin-anchor" href="#personal-safety-csrf-tips-for-users"><i class="fa fa-link" aria-hidden="true"></i></a>Personal Safety CSRF Tips for Users</h1>
<p>Since CSRF vulnerabilities are reportedly widespread, we recommend using the following best practices to mitigate risk.</p>
<ol>
<li>Logoff immediately after using a Web application.</li>
<li>Do not allow your browser to save username/passwords, and do not allow sites to &#x201C;remember&#x201D; your login.</li>
<li>Do not use the same browser to access sensitive applications and to surf the Internet freely (tabbed browsing).</li>
<li>The use of plugins such as No-Script makes POST based CSRF vulnerabilities difficult to exploit. This is because JavaScript is used to automatically submit the form when the exploit is loaded. Without JavaScript, the attacker would have to trick the user into submitting the form manually.
Integrated HTML-enabled mail/browser and newsreader/browser environments pose additional risks since simply viewing a mail message or a news message might lead to the execution of an attack. </li>
</ol>
<h1 id="implementation-reference-example"><a name="implementation-reference-example" class="plugin-anchor" href="#implementation-reference-example"><i class="fa fa-link" aria-hidden="true"></i></a>Implementation reference example</h1>
<p>The following JEE web filter provides an example reference for some of the concepts described in this cheatsheet. It implements the following stateless mitigations (<a href="https://github.com/aramrami/OWASP-CSRFGuard" target="_blank">OWASP CSRFGuard</a>, cover a stateful approach).</p>
<ul>
<li>Verifying same origin with standard headers</li>
<li>Double submit cookie</li>
<li>SameSite cookie attribute</li>
</ul>
<p><strong>Please note</strong> that it only acts a reference sample and is not complete (for example: it doesn&#x2019;t have a block to direct the control flow when origin and referrer header check succeeds nor it has a port/host/protocol level validation for referrer header). Developers are recommended to build their complete mitigation on top of this reference sample. Developers should also implement standard authentication or authorization checks before checking for CSRF.</p>
<p>Source is also located <a href="https://github.com/righettod/poc-csrf" target="_blank">here</a> and provides a runnable POC.</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;

<span class="hljs-keyword">import</span> javax.servlet.Filter;
<span class="hljs-keyword">import</span> javax.servlet.FilterChain;
<span class="hljs-keyword">import</span> javax.servlet.FilterConfig;
<span class="hljs-keyword">import</span> javax.servlet.ServletException;
<span class="hljs-keyword">import</span> javax.servlet.ServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.ServletResponse;
<span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;
<span class="hljs-keyword">import</span> javax.servlet.http.Cookie;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponseWrapper;
<span class="hljs-keyword">import</span> javax.xml.bind.DatatypeConverter;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.MalformedURLException;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.security.SecureRandom;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/**
 * Filter in charge of validating each incoming HTTP request about Headers 
 * and CSRF token.
 * It is called for all requests to backend destination.
 *
 * We use the approach in which:
 * - The CSRF token is changed after each valid HTTP exchange
 * - The custom Header name for the CSRF token transmission is fixed
 * - A CSRF token is associated to a backend service URI in order to enable 
 *   the support for multiple parallel Ajax request from the same application
 * - The CSRF cookie name is the backend service name prefixed with a fixed prefix
 *
 * Here for the POC we show the &quot;access denied&quot; reason in the response but in 
 * production code only return a generic message !
 *
 * <span class="hljs-doctag">@see</span> &quot;https://wiki.mozilla.org/Security/Origin&quot;
 * <span class="hljs-doctag">@see</span> &quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie&quot;
 * <span class="hljs-doctag">@see</span> &quot;https://chloe.re/2016/04/13/goodbye-csrf-samesite-to-the-rescue/&quot;
 */</span>
<span class="hljs-meta">@WebFilter</span>(<span class="hljs-string">&quot;/backend/*&quot;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSRFValidationFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>{

    <span class="hljs-comment">/**
     * JVM param name used to define the target origin
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TARGET_ORIGIN_JVM_PARAM_NAME = <span class="hljs-string">&quot;target.origin&quot;</span>;

    <span class="hljs-comment">/**
     * Name of the custom HTTP header used to transmit the CSRF token and also to prefix
     * the CSRF cookie for the expected backend service
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CSRF_TOKEN_NAME = <span class="hljs-string">&quot;X-TOKEN&quot;</span>;

    <span class="hljs-comment">/**
     * Logger
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOG = LoggerFactory.getLogger(CSRFValidationFilter.class);

    <span class="hljs-comment">/**
     * Application expected deployment domain: named &quot;Target Origin&quot; in OWASP CSRF article
     */</span>
    <span class="hljs-keyword">private</span> URL targetOrigin;

    <span class="hljs-comment">/***
     * Secure generator
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SecureRandom secureRandom = <span class="hljs-keyword">new</span> SecureRandom();


    <span class="hljs-comment">/**
     * {<span class="hljs-doctag">@inheritDoc</span>}
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> 
    <span class="hljs-keyword">throws</span> IOException, ServletException </span>{
        HttpServletRequest httpReq = (HttpServletRequest) request;
        HttpServletResponse httpResp = (HttpServletResponse) response;
        String accessDeniedReason;

        <span class="hljs-comment">/* STEP 1: Verifying Same Origin with Standard Headers */</span>
        <span class="hljs-comment">//Try to get the source from the &quot;Origin&quot; header</span>
        String source = httpReq.getHeader(<span class="hljs-string">&quot;Origin&quot;</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isBlank(source)) {
            <span class="hljs-comment">//If empty then fallback on &quot;Referer&quot; header</span>
            source = httpReq.getHeader(<span class="hljs-string">&quot;Referer&quot;</span>);
            <span class="hljs-comment">//If this one is empty too then we trace the event and we block the request </span>
            <span class="hljs-comment">//(recommendation of the article)...</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isBlank(source)) {
                accessDeniedReason = <span class="hljs-string">&quot;CSRFValidationFilter: ORIGIN and REFERER request&quot;</span> + 
                <span class="hljs-string">&quot;headers are both absent/empty so we block the request !&quot;</span>;
                LOG.warn(accessDeniedReason);
                httpResp.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedReason);
                <span class="hljs-keyword">return</span>;
            }
        }

        <span class="hljs-comment">//Compare the source against the expected target origin</span>
        URL sourceURL = <span class="hljs-keyword">new</span> URL(source);
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.targetOrigin.getProtocol().equals(sourceURL.getProtocol()) || 
            !<span class="hljs-keyword">this</span>.targetOrigin.getHost().equals(sourceURL.getHost())
        || <span class="hljs-keyword">this</span>.targetOrigin.getPort() != sourceURL.getPort()) {
            <span class="hljs-comment">//One the part do not match so we trace the event and we block the request</span>
            accessDeniedReason = String.format(<span class="hljs-string">&quot;CSRFValidationFilter: Protocol/Host/Port &quot;</span> + 
            <span class="hljs-string">&quot;do not fully matches so we block the request! (%s != %s) &quot;</span>,
                <span class="hljs-keyword">this</span>.targetOrigin, sourceURL);
            LOG.warn(accessDeniedReason);
            httpResp.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedReason);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">/* STEP 2: Verifying CSRF token using &quot;Double Submit Cookie&quot; approach */</span>
        <span class="hljs-comment">//If CSRF token cookie is absent from the request then we provide one </span>
        <span class="hljs-comment">//in response but we stop the process at this stage.</span>
        <span class="hljs-comment">//Using this way we implement the first providing of token</span>
        Cookie tokenCookie = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (httpReq.getCookies() != <span class="hljs-keyword">null</span>) {
            String csrfCookieExpectedName = <span class="hljs-keyword">this</span>.determineCookieName(httpReq);
            tokenCookie = Arrays.stream(httpReq.getCookies()).filter(c 
            -&gt; c.getName().equals(csrfCookieExpectedName)).findFirst().orElse(<span class="hljs-keyword">null</span>);
        }
        <span class="hljs-keyword">if</span> (tokenCookie == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">this</span>.isBlank(tokenCookie.getValue())) {
            LOG.info(<span class="hljs-string">&quot;CSRFValidationFilter: CSRF cookie absent or value&quot;</span> + 
            <span class="hljs-string">&quot; is null/empty so we provide one and return an HTTP NO_CONTENT response !&quot;</span>);
            <span class="hljs-comment">//Add the CSRF token cookie and header</span>
            <span class="hljs-keyword">this</span>.addTokenCookieAndHeader(httpReq, httpResp);
            <span class="hljs-comment">//Set response state to &quot;204 No Content&quot; in order to allow the requester to </span>
            <span class="hljs-comment">//clearly identify an initial response providing the initial CSRF token</span>
            httpResp.setStatus(HttpServletResponse.SC_NO_CONTENT);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//If the cookie is present then we pass to validation phase</span>
            <span class="hljs-comment">//Get token from the custom HTTP header (part under control of the requester)</span>
            String tokenFromHeader = httpReq.getHeader(CSRF_TOKEN_NAME);
            <span class="hljs-comment">//If empty then we trace the event and we block the request</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isBlank(tokenFromHeader)) {
                accessDeniedReason = <span class="hljs-string">&quot;CSRFValidationFilter: Token provided via HTTP Header&quot;</span>+ 
                <span class="hljs-string">&quot; is absent/empty so we block the request !&quot;</span>;
                LOG.warn(accessDeniedReason);
                httpResp.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedReason);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tokenFromHeader.equals(tokenCookie.getValue())) {
                <span class="hljs-comment">//Verify that token from header and one from cookie are the same</span>
                <span class="hljs-comment">//Here is not the case so we trace the event and we block the request</span>
                accessDeniedReason = <span class="hljs-string">&quot;CSRFValidationFilter: Token provided via HTTP Header&quot;</span>+ 
                <span class="hljs-string">&quot;and via Cookie are not equals so we block the request !&quot;</span>;
                LOG.warn(accessDeniedReason);
                httpResp.sendError(HttpServletResponse.SC_FORBIDDEN, accessDeniedReason);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//Verify that token from header and one from cookie matches</span>
                <span class="hljs-comment">//Here is the case so we let the request reach the target component </span>
                <span class="hljs-comment">//(ServiceServlet, jsp...) and add a new token when we get back the bucket</span>
                HttpServletResponseWrapper httpRespWrapper = 
                                            <span class="hljs-keyword">new</span> HttpServletResponseWrapper(httpResp);
                chain.doFilter(request, httpRespWrapper);
                <span class="hljs-comment">//Add the CSRF token cookie and header</span>
                <span class="hljs-keyword">this</span>.addTokenCookieAndHeader(httpReq, httpRespWrapper);
            }
        }
    }

    <span class="hljs-comment">/**
     * {<span class="hljs-doctag">@inheritDoc</span>}
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>{
        <span class="hljs-comment">//To easier the configuration, we load the target expected origin from </span>
        <span class="hljs-comment">//an JVM property</span>
        <span class="hljs-comment">//Reconfiguration only require an application restart that is generally acceptable</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">this</span>.targetOrigin = <span class="hljs-keyword">new</span> URL(System.getProperty(TARGET_ORIGIN_JVM_PARAM_NAME));
        } <span class="hljs-keyword">catch</span> (MalformedURLException e) {
            LOG.error(<span class="hljs-string">&quot;Cannot init the filter !&quot;</span>, e);
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(e);
        }
        LOG.info(<span class="hljs-string">&quot;CSRFValidationFilter: Filter init, set expected target origin to &apos;{}&apos;.&quot;</span>, 
                 <span class="hljs-keyword">this</span>.targetOrigin);
    }

    <span class="hljs-comment">/**
     * {<span class="hljs-doctag">@inheritDoc</span>}
     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>{
        LOG.info(<span class="hljs-string">&quot;CSRFValidationFilter: Filter shutdown&quot;</span>);
    }

    <span class="hljs-comment">/**
     * Check if a string is null or empty (including containing only spaces)
     *
     * <span class="hljs-doctag">@param</span> s Source string
     * <span class="hljs-doctag">@return</span> TRUE if source string is null or empty (including containing only spaces)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBlank</span><span class="hljs-params">(String s)</span> </span>{
        <span class="hljs-keyword">return</span> s == <span class="hljs-keyword">null</span> || s.trim().isEmpty();
    }

    <span class="hljs-comment">/**
     * Generate a new CSRF token
     *
     * <span class="hljs-doctag">@return</span> The token a string
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateToken</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">50</span>];
        <span class="hljs-keyword">this</span>.secureRandom.nextBytes(buffer);
        <span class="hljs-keyword">return</span> DatatypeConverter.printHexBinary(buffer);
    }

    <span class="hljs-comment">/**
     * Determine the name of the CSRF cookie for the targeted backend service
     *
     * <span class="hljs-doctag">@param</span> httpRequest Source HTTP request
     * <span class="hljs-doctag">@return</span> The name of the cookie as a string
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">determineCookieName</span><span class="hljs-params">(HttpServletRequest httpRequest)</span> </span>{
        String backendServiceName = httpRequest.getRequestURI().replaceAll(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>);
        <span class="hljs-keyword">return</span> CSRF_TOKEN_NAME + <span class="hljs-string">&quot;-&quot;</span> + backendServiceName;
    }

    <span class="hljs-comment">/**
     * Add the CSRF token cookie and header to the provided HTTP response object
     *
     * <span class="hljs-doctag">@param</span> httpRequest  Source HTTP request
     * <span class="hljs-doctag">@param</span> httpResponse HTTP response object to update
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTokenCookieAndHeader</span><span class="hljs-params">(HttpServletRequest httpRequest, 
                                         HttpServletResponse httpResponse)</span> </span>{
        <span class="hljs-comment">//Get new token</span>
        String token = <span class="hljs-keyword">this</span>.generateToken();
        <span class="hljs-comment">//Add cookie manually because the current Cookie class implementation </span>
        <span class="hljs-comment">//do not support the &quot;SameSite&quot; attribute</span>
        <span class="hljs-comment">//We let the adding of the &quot;Secure&quot; cookie attribute to the reverse proxy rewriting...</span>
        <span class="hljs-comment">//Here we lock the cookie from JS access and we use the SameSite new attribute protection</span>
        String cookieSpec = String.format(<span class="hljs-string">&quot;%s=%s; Path=%s; HttpOnly; SameSite=Strict&quot;</span>, 
                            <span class="hljs-keyword">this</span>.determineCookieName(httpRequest), token, httpRequest.getRequestURI());
        httpResponse.addHeader(<span class="hljs-string">&quot;Set-Cookie&quot;</span>, cookieSpec);
        <span class="hljs-comment">//Add cookie header to give access to the token to the JS code</span>
        httpResponse.setHeader(CSRF_TOKEN_NAME, token);
    }
}
</code></pre>
<h1 id="authors-and-primary-editors"><a name="authors-and-primary-editors" class="plugin-anchor" href="#authors-and-primary-editors"><i class="fa fa-link" aria-hidden="true"></i></a>Authors and Primary Editors</h1>
<p><a href="http://www.manideepk.com" target="_blank">Manideep Konakandla (Amazon Application Security Team)</a></p>
<p>Dave Wichers - dave.wichers@owasp.org</p>
<p>Paul Petefish</p>
<p>Eric Sheridan - eric.sheridan@owasp.org</p>
<p>Dominique Righetto - dominique.righetto@owasp.org</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Credential_Stuffing_Prevention_Cheat_Sheet.html" class="navigation navigation-prev " aria-label="Previous page: Credential Stuffing Prevention ">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Cross_Site_Scripting_Prevention_Cheat_Sheet.html" class="navigation navigation-next " aria-label="Next page: Cross Site Scripting Prevention ">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Cross-Site Request Forgery Prevention ","level":"1.18","depth":1,"next":{"title":"Cross Site Scripting Prevention ","level":"1.19","depth":1,"path":"cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md","ref":"cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md","articles":[]},"previous":{"title":"Credential Stuffing Prevention ","level":"1.17","depth":1,"path":"cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.md","ref":"cheatsheets/Credential_Stuffing_Prevention_Cheat_Sheet.md","articles":[]},"dir":"ltr"},"config":{"plugins":["anchors"],"root":"./cheatsheets","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"anchors":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"Preface.md","glossary":"GLOSSARY.md","summary":"TOC.md"},"variables":{},"title":"OWASP Cheat Sheet Series","language":"en","gitbook":"*","description":"Website with the collection of all the cheat sheets of the project."},"file":{"path":"cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.md","mtime":"2019-04-22T06:22:13.126Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-04-22T06:22:45.883Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

