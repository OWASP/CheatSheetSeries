# Symfony Cheat Sheet
## Introduction

This *Cheat Sheet* aims to provide developers with security tips when building applications using the Symfony framework. It covers common vulnerabilities and best practices to ensure that your Symfony applications are secure.

While Symfony comes with built-in security mechanisms, developers must be aware of potential vulnerabilities and best practices to ensure the applications they build are secure. This guide aims to cover common security issues, emphasizing the importance of understanding Symfony's security features and how to utilize them effectively.
Whether you're a newcomer to Symfony or an experienced developer looking to reinforce your security practices, this document serves as a valuable resource. By following the guidelines outlined here, you can strengthen the security of your Symfony applications and create a safer digital environment for users and data.


## Main Sections

### Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) is a type of attack where malicious JavaScript code is injected into a displayed variable. For example, if the value of the variable name is `<script>alert('hello')</script>`, and we display it in HTML like this: `Hello {{name}}`, the injected script will be executed when the HTML is rendered.

Symfony comes by default with twig templates that automatically protect applications from XSS attacks by using **output escaping** to transform variables containing special characters by wrapping variable with `{{ }}` statement.

```twig
<p>Hello {{name}}</p>
{# if 'name' is '<script>alert('hello!')</script>', Twig will output this:
'<p>Hello &lt;script&gt;alert(&#39;hello!&#39;)&lt;/script&gt;</p>' #}
```
If you are rendering a variable that is trusted and contains HTML contents, you can use *Twig raw filter* to disable output escaping.

```twig
<p>{{ product.title|raw }}</p>
{# if 'product.title' is 'Lorem <strong>Ipsum</strong>', Twig will output
exactly that instead of 'Lorem &lt;strong&gt;Ipsum&lt;/strong&gt;' #}
```

Explore the [Twig output escaping documentation](https://twig.symfony.com/doc/3.x/api.html#escaper-extension) to gain insights into disabling output escaping for a specific block or an entire template.

For other information on XSS prevention that is not specific to Symfony, you may refer the [Cross Site Scripting Prevention Cheatsheet](Cross_Site_Scripting_Prevention_Cheat_Sheet.md).


### Cross-Site Request Forgery (CSRF)

Symfony Form component automatically includes CSRF tokens in the forms, providing built-in protection against CSRF attacks. Symfony validates these tokens automatically, eliminating the need for manual intervention to safeguard your application.

By default Symfony adds the CSRF token in a hidden field called `_token`, but this can be customized with other settings on a form-by-form basis:

```php
namespace App\Form;

// ...

class PostForm extends AbstractType
{
    // ...

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            // ... 
            'csrf_protection' => true,  // enable/disable csrf protection for this form
            'csrf_field_name' => '_csrf_token',
            'csrf_token_id'   => 'post_item', // change arbitrary string used to generate
        ]);
    }

    // ...
}
```

If you don't use Symfony Forms you can generate and validate CSRF tokens by yourself. To do this you have to install `symfony/security-csrf` component.
```bash
composer install symfony/security-csrf
```
Enable/disable the CSRF protection in `config/packages/framework.yaml` file:
```yaml
framework:
    csrf_protection: ~
```

Next consider this HTML Twig template when CSRF token is generated by `csrf_token()` Twig function

```twig
<form action="{{ url('delete_post', { id: post.id }) }}" method="post">
    <input type="hidden" name="token" value="{{ csrf_token('delete-post') }}">
    <button type="submit">Delete post</button>
</form>
```
Then you can get value of CSRF token in controller using `isCsrfTokenValid()` function:
```php
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class ExampleController 
{

    // ... 

    #[Route('/posts/{id}', methods: ['DELETE'], name: 'delete_post')]
    public function delete(Post $post, Request $request): Response 
    { 
        $token = $request->request->get('token')

        if($this->isCsrfTokenValid($token)) {
            // ...
        }
        
        // ...
    }
}
```

You can find more information about CSRF not related to Symfony in [Cross-Site Request Forgery (CSRF) Cheat Sheet](Cross_Site_Request_Forgery_Prevention_Cheat_Sheet.md).


### Session Security

### SQL Injection

### Command Injection

Command Injection occurs when malicious code is injected into an application system and executed.


Consider the following example, where file is removed using the exec() function without any input escaping:

```php

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class ExampleController 
{

    // ...

    #[Route('/remove_file', methods: ['POST'])]
    public function removeFile(Request request): Response
    {
        $filename =  $request->request->get('filename');
        exec(sprintf('rm %s', $filename));

        // ...
    }
}
```

In this code, there is no validation of user input. Imagine what could happen if a user provides a malicious value like `test.txt && rm -rf ..`.  To mitigate this risk, it is advisable to use native PHP functions like `unlink()` instead of `exec()`.

For specific PHP filesystem functions relevant to your case, refer to the [PHP documentation](https://www.php.net/manual/en/refs.fileprocess.file.php).







### Open Redirection


Open Redirection is a security flaw that occurs when a web application redirects users to a URL specified in an invalidated parameter. Attackers exploit this vulnerability to redirect users to malicious sites.

In the provided PHP code snippet:
```php

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;


class ExampleController extends AbstractController 
{
    // ...

    #[Route('/dynamic_redirect', methods: ['GET'])]
    public function dynamicRedirect(Request request): Response 
    {
        $url = $request->query->get('url');
        return $this->redirect($url);

    }
}

```
The controller function redirects users based on the `url` query parameter without proper validation. Attackers can craft malicious URLs, leading unsuspecting users to malicious sites. To prevent open redirection, always validate and sanitize user input before redirection, and avoid using untrusted input directly in redirect functions.




## References

Any useful references to other useful resources that aren't linked inline elsewhere in the cheat sheet.

